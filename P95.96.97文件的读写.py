# 文件的操作
# 文件操作的一般步骤
# 打开文件->读写文件->保存文件->关闭文件

# 用open函数打开一个已经存在的文件，或者创建一个新文件
# 语法  open('文件完整的路径'.'打开模式')
"""
文件打开的模式
r 以只读方式打开文件。文件的指针会将放在文件的开头，这是默认模式
w 打开一个文件只用于写入，如果该文件已经存在则将其覆盖，如果该文件不存在，创建新文件
a 打开一个文件用于追加，如果该文件已经存在，文件指针将会放在文件的结尾，也就是说，新的文件内容将会被写入已有内容之后。
如果该文件不存在，创建新的文件写入
rb 以二进制的格式打开一个文件用于只读。文件指针将会放在文件的开头，这是默认模式
wb 以二进制的格式打开一个文件用于写入，如果该文件已经存在则将其覆盖，如果该文件不存在，创建新文件
ab 以二进制的格式打开一个文件用于追加，如果该文件已经存在，文件指针将会放在文件的结尾，也就是说，新的文件内容将会被写入已有内容之后。
如果该文件不存在，创建新的文件写入
r+ 打开一个文件用于读写，文件中指针将会放在文件的开头
w+ 打开一个文件用于读写，如果该文件已经存在则将其覆盖，如果该文件不存在，创建新文件
a+ 打开一个文件用于读写，如果该文件已存在，文件指针将会放在文件的结尾，文件打开时会是追加模式
如果该文件不存在，创建新文件用于读写
rb+ 以二进制的格式打开一个文件用于只读。文件指针将会放在文件的开头
wb+ 以二进制的格式打开一个文件用于写入，如果该文件已经存在则将其覆盖，如果该文件不存在，创建新文件
ab+ 以二进制的格式打开一个文件用于追加，如果该文件已经存在，文件指针将会放在文件的结尾
如果该文件不存在，创建新的文件读写


"""
# 默认的编码时gbk 中文编码，最好的习惯就是我们在打开一个文件的时候
# 给它指定一个编码类型'utf-8'
# open('./test.txt','w',encoding='utf-8')  #open执行完会返回一个文件对象，这里相当于创建一个文件对象
# fobj=open('./test.txt','w')  #将文件对象赋值给fobj变量
# # 开始操作，读写操作
# fobj.write('在那遥远的地方')  #这是写到内存理店，没有到硬盘里，因此需要保存
# fobj.write('你好大海')   #如果文件已经存在，每次用w打开这个文件写入，会覆盖上一次的
# fobj.close()#这个关闭就是保存加关闭


# 以二进制的方式去写数据
# 结果上没变化，在写入发过程里会将我们写入的东西转化为二进制，str-->bytes，以字节的形式写的
# fobj=open('test1.txt','wb')  #多次用wb打开同样会覆盖原文件
# fobj.write('你好啊哈哈哈哈'.encode('utf-8'))  #将字符串转化为二进制用.encode(编码形式)
# fobj.close()

# fobj=open('test.txt','a')  #a表示追加，如果有点话不会覆盖，如果没有会创建
# fobj.write('你好啊哈哈哈哈\r\n')  #换行\r空一行写入  \n换行写入
# fobj.write('换行了啊啊啊\n')
# fobj.write('123')
#
# fobj.close()

# 用不同打开模式写入，会编码错误
# fobj=open('test.txt','ab')  #a表示追加，如果有点话不会覆盖，如果没有会创建
# fobj.write('用二进制\n'.encode('utf-8'))  #换行\r空一行写入  \n换行写入
# fobj.write('写入了啊啊啊\n'.encode('utf-8'))
# fobj.write('456\n'.encode('utf-8'))
# fobj.close()
# 写好之后要开始读了

# 读文件
# fobj=open('test.txt','r',encoding='utf-8')
# print(fobj.read())  #一次性将文件内容全部取出,如果一次性读完了，读文件的指针就在文件末尾了，后面就读不到东西了

# content=fobj.read(4)  #传入一个数字做参数，表示读取指定的字符个数
# print(content)
# content=fobj.read() #第二次读取将从第一次读取的位置继续读取
# print(content)

# content=fobj.readlines()  #一次性读取所有内容，返回一个列表，列表元素为每一行内容
# print(content)

# content=fobj.readline()  #只读取一行 ，区分:readlines逐行读取全部
# print(content)
# fobj.close() #关闭文件

# 以二进制的形式读取文件
# fobj=open('test.txt','rb')
# data=fobj.read()
# # 写文件的时候如果以gbk来写的，解码的时候也要用gbk来解码
# # 如果用二进制来写的utf-8 解码的时候也要用utf-8来解码
# print(data.decode('utf-8'))  #decode解码形式  以utf-8的形式解码
# fobj.close()  #当数据量大的时候，如果操作完如果不关闭，会造成文件对象不能释放，导致内存泄露


# with的使用 上下文管理对象 优点:自动释放打开关联的对象
# with语句，不管在处理文件过程中是否发生异常，都能保证with语句执行完毕后，已经关闭打开的文件
with open('test.txt', 'a') as f:  #给打开的对象起个别名f
    # print(f.read())
    f.write('我觉得python很好学\n')

#小结
# 文件读写的几种操作方式
# read r r+ rb rb+
# r r+  使用普通的读取场景
# rb rb+  适用于文件 图片 音频 这样的文件读取
# write w  w+  wb  wb+  a  ab
# w wb w+ 每次都会创建文件
# 二进制读写的时候要注意编码问题，默认情况下，我们写入文件的编码时gbk,特定的情况下用encoding显式的去指示以什么编码写入
# a ab a+  在原有的文件的基础上去追加，在文件指针的末尾去追加，并不会每次都会创建一个新文件























