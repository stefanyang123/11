# 私有化属性
# 修改属性都是直接通过类名修改的。如果有些首要的属性不想让别人随便修改，或防止意外修改，怎么办？
# 为了更好的保存属性安全，即不能随意修改，将属性定义为私有属性，可以添加一个可调用的方法去访问
# 语法  __属性名
# 通过两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问

# 使用私有属性的场景
# 1.把特定的一个属性隐藏起来，不想让类的外部进行直接调用
# 2.我想保护这个属性，不想让属性的值随意的改变
# 3.保护这个属性，不想让派生类（子类）去继承

class Person:
    __hobby='跳舞'  #类属性
    def __init__(self,):
        self.__name='李四' #加__将此属性私有化 ，私有化后就不能在外部直接访问了，在类的内部是可以访问的
        self.age=30
        pass
    def __str__(self):
        """
        私有化的属性在内部可以使用
        :return:
        """
        return '{}的年龄是{}，爱好是{}'.format(self.__name,self.age,self.__hobby)  #类的内部可以访问

    def changeValue(self):
        Person.__hobby='唱歌'

    pass
class Student(Person):   #私有属性不能被子类继承
    pass

# 私有化之后最大的特点是，属性，在类的内部可以访问，但是在外部访问不了，因此也不能继承
xl=Person()
# print(xl.__name)  #是通过实例对象 在外部访问的__name  发现访问不了
print(xl)

# print(Person.__hobby) 发现类对象已经不能从外面访问私有化的类属性了
# print(xl.__hobby)  发现实例对象也已经 不能从外部访问私有化的类属性

# 结论
# 1.私有化的实例属性，不能在外部直接的访问，可以在类的内部随意的使用
# 2.子类不能继承父类的私有化属性，(只能继承父类的公共的属性和行为)
# 3.在属性名的前面直接加__就可以变为私有化了


# Person.changeValue(Person) 也可以用这个代码
xl.changeValue()   #先执行changevalue函数，在打印xl,可以改变私有化属性的值
print(xl)


















